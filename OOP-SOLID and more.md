### Q&A
* ¿Qué es un paradigma de programación? Es una forma de clasificar a los lenguajes de programación en función de sus características y se ocupan principalmente de las implicancias para el modelo de ejecución del lenguaje, la forma en que se organiza el código y el estilo de sintaxis y gramática. Los más comunes son: Imperativo y declarativo. Paradigma imperativo se refiere a que el programador instruye a la máquina sobre cómo cambiar su estado, esto incluye paradigma procedimental (que agrupa las instrucciones en procedimientos) y paradigma orientado a objetos (que agrupa las instrucciones con la parte del estado en el que operan). El paradigma declarativo se refiere a que el programador solamente declara las propiedades del resultado deseado, pero no cómo calcularlo. Esto incluye el paradigma de programación funcional (en que el resultado deseado se declara como el valor de una serie de aplicaciones de función), y paradigma lógico (en que el resultado se declara como la respuesta a una pregunta sobre un sistema de reglas), paradigma matemático (en que el resultado deseado se declara como solución a un problema de optimización) y paradigma reactivo (en el que se declara el resultado deseado con flujos de datos y la propagación de un cambio).

* Solid: Principios de diseño
	* S: Single responsibility, solo una responsabilidad por cada clase. Un método, una clase, un módulo, un software debe tener un sólo motivo para cambiar. Por ej. Una clase que se encarga de parsear archivos csv, pero además la clase es responsable de saber cómo abrir el archivo. Esto está mal porque tiene 2 responsabilidades.
	* O: Open and Close principle, abierto para extensión pero cerrado para modificación. Uso de abstract class que son heredables. Por ej. Interfaz que tiene método para parsear archivos y acepta ciertos parámetros. Si me hace falta especificar los parámetros de ese comportamiento puedo tomar esa clase, implementarla y utilizarla. 
	* L: Liskov substitution principle, subtipos deben poder ser sustituidos por sus tipos de base. Tiene que ver con herencia. Por ej. Objetos de una superclase podrían ser reemplazados por sus subclases sin dañar la aplicación.
	* I: Interface segregation principle, depender de interfaces lo más pequeñas posibles para no estar forzando la implementación de interfaces o métodos que no son necesarias. Crear múltiples interfaces y luego si es necesario, hacer uso de varias interfaces.
	* D: Dependency inversion principle, es un principio que describe un conjunto de técnicas destinadas a disminuir el acoplamiento entre los componentes de una aplicación. También se conoce como Inversión de control y se refiere a depender de abstracciones o interfaces y no de clases concretas. Este principio propone evitar las dependencias rígidas entre componentes mediante uso de abstracciones en lugar de referencias directas entre clases y de esta forma hacer que una clase reciba referencias de los componentes que necesita para funcionar en vez de instanciarlos directamente.  El objetivo principal de este principio es asegurar que los cambios que se realicen no alteren el contrato de entrada y salida que está establecido por las abstracciones. Esto se conoce como backwards compatibility. 

* Inversión de control: es un principio donde hay un objeto o un programa que cede el control a alguien más, un framework u otro objeto. Formas de implementarlo: 1. Utilizando patrones de diseño que sirven para esto, como el patrón Template y el patrón Factory. 2. Service locator: es un objeto que asociado a una clase, le ayuda a resolver dependencias. 3. Inyección de dependencias: es la manera más común de hacer inversión de control y por eso a veces se confunden los conceptos.

* Inyección de dependencias: es una técnica donde a un objeto se le proveen las dependencias que necesita. Estas pueden venir en forma de objeto o de valores que el otro objeto va a necesitar en algún momento de su ciclo de vida. Esto implica que no es el objeto el que controla cómo va a obtener las dependencias, sólo las recibe, y le da el control de obtenerlas a otro objeto. Esto se puede hacer de 4 formas distintas: por constructor, por setter, por métodos y por interfaces. Por ej. Una interface que se llame Injector y lleve las dependencias. La inyección de dependencias permite hacer modificaciones de implementación en tiempo de ejecución. También hace que el código sea más fácil de probar utilizando Mocks en los test. La inyección de dependencias ayuda proveyendo bajo acoplamiento. Se puede hacer con o sin frameworks. Inyección de dependencias es la técnica donde un objeto provee las dependencias que otro objeto requiere. Algunas características son que reduce el acoplamiento entre clases ya que las clases no obtienen sus dependencias de otro componentes

* Patrones de diseño: son soluciones probadas a problemas reales que se han presentado de manera repetida en el pasado. Luego con el tiempo se han ido verificando estos patrones que dan solución efectiva a esos problemas y funcionan correctamente.
	* Patrones creacionales: permiten contar con varios mecanismos de creación de objetos, entrega mayor flexibilidad y permite reutilizar código.
		* Factory Method: también llamado método fábrica y constructor virtual. Este patrón proporciona una interfaz para crear objetos en una superclase, de modo que permite a la subclases alterar el tipo de objetos que se crearán.
		* Singleton: patrón de diseño en que el constructor es de tipo privado por lo que no se pueden instanciar nuevos objetos de esa clase, de modo que se accede al recurso a través de una misma y sola instancia. Hay 3 formas de implementar el patrón Singleton: sincrónica, asincrónica y única. Este patrón asegura que una clase tenga una sola instancia como acceso global.
		* Abstract Factory: es un patrón que permite producir familias de objetos relacionados sin especificar sus clases concretas. Se realiza mediante la declaración de interfaces para las familias de objetos, quienes posteriormente tendrán sus propias especificaciones.
		* Builder: permite construir objetos paso a paso, produciendo distintos tipos y representaciones de un objeto empleando el mismo código de construcción. Esto se realiza sacando el código de construcción del objeto de su propia clase y colocándolo dentro de objetos independientes llamados builders.
		* Prototype: este patrón de diseño permite copiar objetos existentes sin que el código dependa de sus clases. Prototype delega el proceso de clonación a los propios objetos que están siendo clonados, así que permite clonar el objeto sin acoplar el código a la clase de ese objeto. 
	* Patrones estructurales: sirven para ensamblar objetos y clases en estructuras más grandes manteniendo la flexibilidad y eficiencia de estas estructuras.
		* Adapter: permite la colaboración entre objetos con interfaces incompatibles. Un adaptador es un objeto especial que convierte la interfaz de un objeto de forma que otro objeto pueda comprenderla.
		 * Bridge: permite dividir una clase grande o un grupo de clases relacionadas en dos jerarquías separadas: abstracción e implementación. En este caso no se refiere a las de java sino a una interfaz de usuario y una API subyacente.
		* Composite: también llamado objeto compuesto y object tree, es un patrón de diseño estructural que permite componer objetos en estructuras de árbol y trabajar con ellas como si fueran objetos individuales. Para poder utilizar este patrón es necesario que el modelo central de la aplicación pueda representarse en forma de árbol. Composite permite ejecutar un comportamiento de forma recursiva sobre todos los componentes de un árbol de objetos.
		* Decorator: permite agregar funcionalidades a objetos. Esto lo hace agregando estos objetos a objetos encapsuladores que son los que tienen las funcionalidades. Para realizar esto se utilizan la agregación y composición en vez de la herencia. Los decoradores pueden ser estructurados como pilas para satisfacer los requerimientos del negocio.
		* Facade: proporciona una interfaz simplificada a una biblioteca o cualquier grupo complejo de clases. Una fachada es una clase que proporciona una interfaz simple a un subsistema complejo que contiene muchas partes móviles y aunque puede entregar una funcionalidad limitada en comparación con el trabajo con el subsistema directo, incluye tan sólo las funciones realmente importantes. También se pueden usar fachadas adicionales para evitar contaminar una única fachada principal con funciones no relacionadas.
		* Flyweight: permite mantener más objetos dentro de una cantidad disponible de RAM, compartiendo las partes comunes del estado entre varios objetos en vez de mantener la información en cada objeto. La información constante de un objeto suele denominarse estado intrínseco, mientras que el resto del estado que se puede alterar  desde afuera por objetos se denomina estado extrínseco. Este patrón de diseño sugiere dejar de almacenar el estado extrínseco dentro del objeto y sólo mantener el estado intrínseco dentro del objeto para poder reutilizarlo en distintos contextos, esto entrega como resultado menor cantidad de estos objetos. El objeto que sólo almacena el estado intrínseco del objeto se llama flyweight. 
		* Proxy: proporciona un sustituto o marcador de posición para otro objeto. El proxy controla el acceso al objeto original permitiendo hacer algo antes o después de que llega la solicitud al objeto original. Se sugiere la creación de una nueva clase proxy con la misma interfaz que un objeto de servicio original, y luego actualizar la aplicación para que pase el objeto proxy a todos los clientes del objeto original, así que proxy crea un objeto de servicio real y se le delega todo el trabajo. El proxy permite realizar alguna ejecución antes o después de la lógica primaria de la clase.
	* Patrones de comportamiento: tratan con algoritmos y la asignación de responsabilidades entre objetos.
		* Cadena de responsabilidad: permite pasar solicitudes a lo largo de una cadena de manejadores, al recibir una solicitud cada manejador decide si la procesa o la traspasa al siguiente manejador de la cadena. También se puede aplicar para extraer una cadena de responsabilidad de un árbol de objetos.
		 * Command: convierte una solicitud en un objeto independiente que contiene toda la información sobre la solicitud, esto permite parametrizar los métodos con diferentes solicitudes, retrasar o poner en cola la ejecución de una solicitud. Toda la información de la solicitud es como un pedido en un restaurante.
		* Iterator: permite recorrer elementos de una colección sin exponer su representación subyacente. La idea central de este patrón es extraer el comportamiento de recorrido de una colección y colocarlo en un objeto independiente llamado iterador. Los iteradores implementan varios algoritmos de recorrido. Varios objetos iteradores pueden recorrer la misma colección al mismo tiempo. Además un objeto iterador encapsula todos los detalles del recorrido. Todos los iteradores deben implementar la misma interfaz, así el código cliente siempre será compatible con cualquier tipo de colección o cualquier algoritmo de recorrido, pero debe ser un iterador adecuado. Es como las diferentes formas de recorrer una ciudad como turista.
		* Mediator: también llamado Controller, permite reducir las dependencias caóticas entre objetos. Este patrón restringe las comunicaciones directas entre objetos, forzándolos a colaborar únicamente a través de un objeto mediador. La idea es que los componentes colaboren indirectamente invocando un objeto mediador especial que redireccione las llamadas a los componentes adecuados.
		* Memento: este patrón permite guardar y restaurar el estado previo de un objeto sin revelar los detalles de su implementación. Lo que hace es que antes de ejecutar una operación la aplicación guarda una instantánea del estado de los objetos que más tarde se puede utilizar para restaurar objetos a su estado previo. La dificultad está en hacer copias del estado privado de un objeto, ya que el estado público no debe usarse por ser inseguro. Así que el patrón Memento delega la creación de instantáneas de estado al propietario del estado y almacena esta copia del estado en un objeto especial llamado memento. Los contenidos del memento no son accesibles para ningún otro objeto excepto el que lo produjo, mientras que elementos cuidadores pueden acceder a metadatos tales como fecha de creación y el nombre de la operación realizada, pero a nada más ya que trabajan desde una interfaz limitada.
		* Observer: también llamado event-subscriber o listener es una patrón de diseño que permite definir un mecanismo de suscripción para notificar a varios objetos sobre cualquier evento que le suceda al objeto que están observando. Hay una clase notificadora a la cual se suscriben clases suscriptoras y en donde la comunicación es mediante una única interfaz que es implementada por todos los suscriptores. La idea es evitar tener que ir a revisar si hay nuevas publicaciones cada vez, sino que recibir la información actualizada vía suscripción.
		* State: es un patrón que permite a un objeto alterar su comportamiento cuando su estado interno cambia. Está relacionado con un concepto llamado máquina de estado finitos que se refiere a que en un momento dado un programa puede encontrarse en un número finito de estados, y en cada estado único el programa se comporta de manera diferente, pudiendo cambiar de un estado a otro de forma instantánea, aunque estas transiciones también son finitas y predeterminadas. Este patrón entonces sugiere la creación de nuevas clases para todos los estados posibles de un objeto, extrayendo todos los comportamientos específicos por estado para ponerlos dentro de esas clases. Luego en vez de implementar todos los comportamientos, se almacena una referencia a uno de los objetos de estado delegando todo el trabajo relacionado con el estado a ese objeto. Si es necesario hacer una transición se sustituye el objeto de estado activo. Esto se puede realizar siempre y cuando todas las clases de estado implementen la misma interfaz.
		* Strategy: permite definir una familia de algoritmos y colocar cada uno de ellos en una clase separada para luego hacer sus objetos intercambiables. Este patrón sugiere tomar una clase que hace una cosa específica pero de varias formas diferentes y extraer todos los algoritmos para colocarlos en clases separadas llamadas estrategias. La clase original llamada contexto tiene un campo para almacenar una referencia a una de las estrategias, que son implementadas por una misma interfaz genérica. 
		* Template method: define el esqueleto de un algoritmo en una superclase y permite que las subclases sobreescriban pasos del algoritmo pero sin cambiar su estructura. Este patrón sugiere la división de un algoritmo en una serie de pasos, convertirlos en métodos y colocar una serie de llamadas a esos métodos en un único método plantilla. Estos pasos pueden ser abstractos o tener una implementación por defecto. Luego para utilizar el algoritmo el cliente debe aportar una subclase propia, implementar los pasos abstractos o sobreescribirlos si es necesario (excepto el método plantilla)
		* Visitor: este patrón de diseño permite separar algoritmos de los objetos sobre los que operan. Se sugiere la creación de una clase separada llamada visitante que contiene el nuevo comportamiento a agregar, en vez de integrarlo dentro de clases existentes. La forma de realizarlo es mediante una técnica llamada Double Dispatch que ayuda a ejecutar el método correcto sobre un objeto sin necesidad de tener condicionales.

* Arquitectura de capas o multicapas: define varias capas en que cada una tiene una responsabilidad, por ejemplo capa de presentación, capa de lógica de negocio, capa de persistencia. En esta arquitectura las capas superiores hacen uso de las capas inferiores.

* Arquitectura hexagonal: La arquitectura de una aplicación define la estructura, organización y relación entre sus componentes. La arquitectura hexagonal es la arquitectura de capas transformada mediante la inyección de dependencias y la inversión de control. Esta arquitectura aísla e independiza el modelo de dominio con el objetivo de que aunque los elementos externos cambien no afecten al modelo. Consta de diferentes módulos: Infraestructura son los elementos externos con los que se comunica la aplicación. Los puntos de entrada pueden ser mediante una api rest o GraphQL, mensajería con RabbitMQ, etc. Puntos de salida pueden ser bases de datos relacionales como PostgreSQL o no relacionales como MongoDB, o envío de mensajes con RabbitMQ. Entonces consta de un core lógico en el centro, aislado del exterior, del cliente y de otras interacciones, y además adaptadores, puertos primarios y secundarios. Lo que busca esta arquitectura es separar el core lógico de la aplicación para que no sea alterada por las modificaciones del exterior. 

* Domain driven design: o DDD es un concepto en que la estructura y el lenguaje en el código debe reflejar el dominio del negocio, esto significa que los nombres de las clases, métodos y variables deben tener relación directa con el negocio al cual está dirigido el software. DDD define dos tipos de patrones: estratégicos y tácticos. Los patrones estratégicos hacen referencia a aspectos del negocio mientras que los patrones tácticos tienen relación con detalles de implementación. Estratégicos: 1. Ubiquitious language son las definiciones aceptadas por todas las personas involucradas en el negocio. 2. Subdominio divide las aplicaciones complejas en  varias áreas funcionales. 3. Bounded context es la aplicación del ubiquitious language. 4. Context map define las relaciones entre los bounded context. Tácticos: 1. Entity es la representación de un objeto identificativo. 2. Value object es un objeto que no tiene identidad propia como una fecha. 3. Aggregate es una entidad que mantiene sin variar un conjunto de entidades y value objects cuando se hacen modificaciones. 4. Service contiene lógica de negocio sin estado, con una función específica de negocio.  5. Factorías son objetos cuya responsabilidad es crear objetos. 6. Repository abstrae a las entidades y aggregates de los detalles de persistencia y búsqueda en bases de datos. 7. Domain events son notificaciones de que han ocurrido cambios en el sistema.
* Manejo de eventos asincrónicos para escalabilidad y consistencia: esto tiene que ver con implementación de comunicación entre microservicios basado en eventos, esto significa que un microservicio publica un evento cuando sucede algo importante y otros microservicios se suscriben a estos eventos (pubsub). Por ejemplo, el primer microservicio actualiza su entidad de negocio y los microservicios suscritos reciben este evento y pueden actualizar sus propias entidades de negocio que a su vez son nuevos eventos. Se basa en un sistema de publicación/suscripción. Comunicación orientada a eventos.

* Rest API: interfaces de programación de aplicaciones que se comunican a través de peticiones HTTP, generalmente se envían y reciben contenidos de tipo JSON, aunque también pueden ser de tipo xml. En aplicaciones REST cada request debe contener toda la información necesaria para ser entendida por el servidor, en vez de que dependa de que el servidor recuerde la información a partir de requests previos. Cuando se almacena el estado de la sesión en el servidor se viola la restricción de estado de la arquitectura REST, así que el estado de la sesión debe ser completamente manejado por el cliente.

* Serverless: significa que uno no se encarga del manejo del servidor sino solo del código. Menos preocupación en la infraestructura (sistemas operativos, hardware, etc) FaaS: function as a service, lo cual permite escalabilidad, alta disponibilidad, sirve para varios lenguajes de programación y se paga por ejecución. Puede ser orientado a eventos. Google Cloud Functions, Azure Functions y AWS Lambda.

* Kafka: Es un sistema de publicación/suscripción de mensajes diseñado para almacenar el registro de todas las transacciones provenientes de logs y monitoreo de aplicaciones. La unidad de datos en Kafka es un mensaje que corresponde a un array de bytes que puede tener una key de metadata. Un batch es una colección de mensajes de un mismo tópico y una misma partición. Los mensajes en Kafka se categorizan en tópicos y estos tópicos pueden ser divididos a su vez en particiones. Hay dos tipos de clientes en Kafka: los productores y los consumidores, productores son los que crean nuevos mensajes, que en otros sistemas pueden ser llamar publishers o writers. Los consumidores leen los mensajes, lo que en otros sistemas pueden llamarse subscribers o readers. 

### Java Core
* Estructuras de datos: Una estructura de datos es un tipo de dato compuesto que actúa como un medio para manejar grandes cantidades de datos y organizar la información de manera eficiente con el objetivo de diseñar una solución correcta para un problema determinado.
	* Una lista simplemente enlazada (Linked List) es una estructura de datos en que cada elemento apunta al siguiente, es una estructura lineal y dinámica que se compone de un conjunto de nodos a los que se puede acceder teniendo la referencia del principio de la lista. 
	* Una pila es una lista ordenada de datos cuyo modo de acceso es de tipo LIFO, último en entrar, primero en salir, y permite almacenar y recuperar datos. 
	* Una cola es una estructura de datos que permite acceder a ellos mediante uno de los extremos de la lista, con la forma FIFO, primero en entrar, primero en salir. La operación push o encolar se realiza por un extremo y pull o desencolar por el otro extremo. 

* Diferencias entre Stringbuffer y Stringbuilder: builder es más eficiente que buffer y no es thread safe. Buffer es thread-safe pero es más lento. Lo que hacen es almacenar cadenas de caracteres pero tienen una serie de métodos para llevar a cabo otras funciones. Ambos son mutables, a diferencia de String que es inmutable, modificar un String implica crear un nuevo objeto. 

* Cómo defino la Inmutabilidad de una clase: ocupando la palabra reservada final, quitando los setters de los atributos, con atributos privados y final.

* Diferencia entre Equals() y operador ==: en Java todo objeto es un puntero que ocupa un espacio en memoria, así que equals() evalúa o compara el valor de este objeto y el operador == evalúa o compara el valor de referencia del objeto, es decir, para ver si ambos objetos apuntan a la misma ubicación en memoria. En resumen equals() compara el valor de 2 objetos y el operador == compara las referencias de los objetos, la ubicación en memoria.

* Colecciones: es una librería de clases e interfaces de Java que hereda de otras clases como Iterable. Dentro de estas librerías hay clases genéricas e interfaces que permiten manejar conjuntos de datos, ordenarlos, recorrerlos, etc. Se basa en estructuras de datos. Algunos tipos: ArrayList, List, Map, Set. De Collection se heredan List, Queue y Set, dentro de List está ArrayList y LinkedList.

* Implementaciones de List: List es una interfaz que se hereda de Collections. Las implementaciones más utilizadas son ArrayList, LinkedList, Stack y Vector. ArrayList basa la implementación de una lista en un array pero que en este caso es dinámico, de tamaño variable, que implementa todos los métodos de List y permite incluir elementos null. ArrayList es una clase genérica que se hereda de AbstractList y que implementa la interfaz List y otras 3 interfaces. LinkedList se basa en la implementación de listas doblemente enlazadas, así que su estructura es un poco más compleja que la de ArrayList. La ventaja de LinkedList es que es mucho más eficiente en cuanto a inserción y eliminación de datos, pero no es eficiente en cuanto a búsqueda de datos. Así que se prefiere LinkedList cuando la prioridad del objeto lista será insertar/eliminar datos, y ArrayList cuando la prioridad de la lista sea búsqueda de información. LinkedList es una clase genérica que se hereda desde AbstractSecuentialList y que implementa las interfaces List y Deque, entre otras. Vector es una implementación sincronizada de List, esto significa que se puede utilizar en entornos concurrentes, en procesos que se ejecutan al mismo tiempo y utilizan al mismo tiempo los mismo recursos. Esta es la única situación en que se recomienda el uso de Vector, ya que es muy similar a ArrayList, contiene  elementos que pueden ser accedidos por un índice y puede aumentar o disminuir su tamaño dinámicamente. Vector es una clase genérica que se hereda desde AbstractList igual que ArrayList, y que implementa la interfaz List y otras 3. Stack es una clase de tipo LIFO y permite tratar a un Vector como pila o stack ya que cuenta con 5 operaciones para esto: push que introduce un elemento en la pila, pop que saca un elemento de la pila, peek que consulta el primer elemento en la pila, empty que comprueba si la pila está vacía y search que busca un determinado elemento dentro de la pila y devuelve su posición dentro de ella. Stack es una clase genérica que se extiende de la clase Vector.

* Implementaciones de Set: es la interfaz encargada de tratar conjuntos en la api de Java. Un conjunto es una colección de elementos que no permite elementos duplicados y que no mantiene un orden en sus elementos. HashSet es la implementación más común de Set y se basa en la implementación de una tabla hash, que es una tabla que se construye en base a claves que permiten localizar objetos. Por este motivo esta implementación es ideal para búsqueda, inserción y borrado de elementos en base a la clave del objeto. Esta implementación no garantiza el orden de los elementos y permite almacenar objetos null. HashSet es una clase genérica que se hereda desde AbstractSet e implementa la interfaz Set entre otras. TreeSet es una implementación que hereda desde la clase AbstractSet que a su vez implementa la interfaz Set, y por eso TreeSet puede implementarse desde Set y desde SortedSet. TreeSet se basa en el uso de una estructura de árbol lo que permite que los elementos estén ordenados de forma natural o mediante el uso de un Comparator. Esto hace que esta implementación haga mucho más rápidas las búsquedas, inserciones o eliminados de elementos. Así que las dos diferencias entre HashSet y TreeSet es que la primera ocupa como estructura para almacenar datos una tabla hash y en el segundo un árbol, y que en HashSet los elementos no están ordenados y en TreeSet sí lo están.  

* FlatMap: junto a Map se usan para operaciones de transformar y mapear. FlatMap es para retornar múltiples valores, a diferencia de Map que sólo transforma un Stream en otro y cada elemento se convierte en un único valor nuevo. Map es one-to-one, FlatMap es one-to-many

* Diferencia entre JPA y Hibernate: jpa es una serie de contratos de interfaces que especifican las funcionalidades que debería tener la aplicación para poder trabajar con persistencias. Hibernate es una implementación de jpa.

* Excepciones en Java: Siempre interactúan 3 keywords que son throw (que es para lanzar excepciones), throws (que es para definir excepciones en un método, en la definición de un método) y el try catch finally que es para capturar las excepciones. En las últimas versiones de Java el catch ya puede capturar múltiples excepciones con el uso de |. A nivel de herencia, como todo en Java es un objeto y tiene herencia, yo puedo crear dos tipos de excepciones: excepciones que extienden de Exception y excepciones que extienden de RuntimeException. Las Checked exceptions son excepciones conocidas o que yo las tengo definidas en mi código y las Unchecked exceptions son excepciones que pueden ocurrir pero que yo no las tengo definidas. Cuando se tiene una excepción Checked se va a retornar (throw) un valor que extiende de Exception y en el caso de una excepción o un método Unchecked se va a retornar (throw) un valor desde RuntimeException. El método que lleva una excepción de tipo checked obliga a definir (throws) la excepción en la declaración del método y por lo tanto cuando yo llame a este método, donde lo quiera utilizar estoy obligada a incluir un try catch, es decir, capturar esta excepción. Esta diferencia se basa en la herencia, es decir, al extender de Exception implica checked, definición y try catch. 

* Concurrencia en Java: el término concurrencia se refiere a dos o más tareas que  se desarrollan en el mismo intervalo de tiempo, pero que no necesariamente progresan en el mismo instante. Paralelismo por otro lado consiste en llevar a cabo multitareas en el mismo instante. Un proceso es un programa en ejecución que tiene su propio espacio en memoria, con enlaces a recursos de entrada y de salida. Estos procesos están aislados entre sí. Un hilo es un camino de ejecución dentro de un proceso y cada proceso tiene al menos un hilo que es el hilo principal. Si hay más de un hilo éstos comparten los recursos del proceso y la memoria. Los agentes que ejecutan los procesos e hilos son las CPU: cada placa base de un computador tiene uno o varios sockets donde insertar procesadores, el número de cores o procesadores tienen relación directa con el número de procesos que podrían ejecutarse en paralelo. Para crear un hilo y ejecutar una tarea se puede crear una clase que extienda a Thread y sobreescribiendo el método run(). Esta tarea se ejecutará cuando una instancia de la clase ejecute el método start(). Otra forma es creando un objeto que implemente la interfaz Runnable y pasándole este objeto al constructor de Thread. Esta forma es la más flexible y menos acoplada al depender de una interfaz.

### OOP
* Definiciones relacionadas con POO: 
	* Objeto es una entidad que tiene un estado y un comportamiento, puede ser un objeto físico o lógico, tangible o intangible. El estado representa la data o el valor de un objeto. El comportamiento se refiere a la funcionalidad de un objeto y la identidad de un objeto se define generalmente como un ID. Un objeto es una instancia de una clase y una clase es una plantilla a partir de la cual los objetos son creados. Una clase contiene campos, métodos, constructores, bloques y clases anidadas e interfaces. Un método es una función que se utiliza para exponer el comportamiento de un objeto. Hay varias formas de crear un objeto en java: con la palabra reservada new, con el método newInstance(), con el método clone(), con deserialización y con factory method, entre otros. Un objeto anónimo se refiere a un objeto sin nombre y que no tiene referencia, sirve para ser utilizado sólo en el momento de la creación del objeto. Un constructor es un bloque de código similar a un método y que se utiliza cuando se crea una nueva instancia de una clase. Al momento de llamar al constructor se genera un espacio de memoria para el objeto recién creado. Los constructores son un tipo de método utilizado para inicializar objetos. Cada vez que se utiliza la palabra new se invoca el constructor. el constructor con parámetros permite entregar diferentes valores a distintos objetos. La sobrecarga de método constructor es una técnica para tener más de un constructor con parámetros, con una lista diferente de parámetros, y el compilador los diferencia de acuerdo al número de parámetros en su lista y los tipos a los que corresponden estos parámetros. Aunque los constructores no tienen la palabra reservada return, sí devuelven algo, esto es la instancia de la clase creada y eso son los valores que retorna, lo que se asignan al utilizarlo. 

	* Herencia: es un mecanismo a través del cual un objeto hereda todas las propiedades y comportamientos de un objeto padre. La idea detrás de la herencia es que se pueden crear clases que se construyen a partir de clases existentes. Cuando se hereda de una clase existente se pueden reutilizar métodos y campos de la clase padre pero además se pueden agregar métodos nuevos y campos nuevos. Los objetivos son la sobreescritura de métodos y la reusabilidad del código. 

	* Polimorfismo es un concepto que se refiere a que se puede llevar a cabo una única acción en diferentes formas, como la palabra lo dice “muchas formas”. 

* Java static keyword: esta palabra es utilizada principalmente para manejo de memoria. Se puede aplicar a variables, métodos y clases. Una variable estática se puede utilizar para referirse a una propiedad común de todos los objetos, es decir que no cambia con cada objeto y esto hace que su espacio en memoria sea obtenido solamente una vez por los objetos creados para esa clase. Un método estático pertenece específicamente a la clase más que al objeto de la clase y puede ser invocado sin la necesidad de crear una instancia de la clase.

* Diferencia entre clase abstracta e interface: la clase abstracta tiene una estructura de abstracción en que la clase padre tiene la estructura de los métodos pero las clases hijas definirán los detalles de los mismos. Pueden tener atributos, métodos y constructores, pero debe tener al menos un método abstracto, que no posee cuerpo y define qué se debe hacer pero no cómo. Estas clases se pueden heredar por varias clases (pero una clase sólo puede heredar desde una clase)  y no se pueden instanciar. Una interfaz es una colección de métodos abstractos, un contrato y se pueden implementar n interfaces, a diferencia de la clase abstracta donde sólo se puede heredar una. Quizás la principal diferencia es que en la clase abstracta puede tener atributos para heredar, mientras que la interfaz nunca lleva a tributos, pero sí podría llevar, desde java 8, métodos implementados con la palabra default. Entonces, si no necesito heredar atributos es mejor utilizar una interfaz.

* ¿Por qué querría tener una interfaz con un método implementado? Para compartir el método con otras clases  y usarlo listo como está. Podría sobreescribirlo, sí, pero también podría no sobreescribirlo y utilizarlo como ya está listo. El objetivo es la reutilización de código.

### Java 8
* Programación funcional vs API funcional de Java: el primero es parte de un paradigma y puede ser implementado en diferentes lenguajes de programación. En cambio la API de Java es una librería de Java con ciertas interfaces e implementaciones basadas en paradigma funcional y que está disponible desde java 8. 

* Interfaces funcionales: son las Predicate, Function, Supplier. Tienen solo un método abstracto y pueden llevar una anotación @FunctionalInterface.

* Streams: Un set de funciones (una librería) para trabajar sobre estructuras de datos. Ayuda a filtrar información. Los streams diseñan un flujo de trabajo que se ejecuta de forma unitaria ítem a ítem, lo que hace que de acuerdo a la solicitud que se hace para filtrar, se ejecuta el flujo de trabajo para el primer elemento y cuando se encuentra el que cumple los requisitos el flujo termina, no recorre el resto de la lista. Esto hace que tenga mejor rendimiento. Función stream().filter().collect(); Evita uso de foreach y permite agregar elementos a una lista. Se puede hacer todo dentro de un mismo stream. Otra función es stream().sorted().collect() y ordena todo en una lista por orden alfabético. Collect, reduce y forEach son terminales, el resto de los métodos se pueden ir encadenando generando procesos de transformación más complejos. [Map, Filter, sorted, etc].

* Java funcional: es otro paradigma de programación, aunque sigue siendo orientado a objetos, aquí la sintaxis cambia a algo más acotado que son los lambdas. Esta es una actualización de Java, no es su formato original.

* Lambdas: forma de escribir variables y métodos relacionados con programación funcional. Tiene una estructura predefinida de flecha -> indica el resultado final que se quiere obtener pero no indica el cómo.

### Spring
* Spring Boot: herramienta del framework Spring que permite generar proyectos con las dependencias y configuraciones necesarias. Spring queda a cargo del manejo de dependencias y librerías. Sus principales ventajas y características son que se implementa Spring de manera rápida con el servidor embebido, con soporte para automatización de Maven o Gradle y gestión de dependencias. También se puede desplegar con Spring config y establecer un tipo de servidor distinto como Jetty. Spring es un framework de Java EE. Spring boot es una extensión de Spring para reducir el tiempo de construcción de una aplicación, entrega una implementación lista con la menor cantidad de código posible. Toma librerías, las inyecta en Spring para llegar y utilizar las implementaciones.

* Anotaciones de estereotipos de Spring: son @Service @RestController y @Repository. Son para que Spring sepa qué es cada cosa, ya que Java internamente va a inyectar diferentes tipos de extensiones para utilizar en cada funcionalidad. Servicio debería ser una capa de coordinación, también se dice que es la que lleva la lógica de negocio pero esto depende de la arquitectura. Controlador es comunicarse con el exterior y gestionar las peticiones hacia el sistema. Repositorio es el que manipula la capa de persistencia.

* Autowired vs qualifier: ambas anotaciones sirven para la inyección de dependencias en Spring, pero Qualifier permite ayudar a Spring Framework a encontrar el bean correcto para inyectar con autowired. Sirve para definir más explícitamente en casos de ambigüedad. 

* Override vs Overload: sobre escritura y sobre carga de métodos. Sobrecarga Overload es cuando 2 o más métodos en la misma clase tienen el mismo nombre pero diferentes parámetros. Override o sobreescritura es cuando la declaración del método tiene el mismo nombre y parámetros tanto en la superclase como en la clase hija.

* Scope por defecto de un bean en spring: Singleton. Scopes en Spring: el scope de un bean define su ciclo de vida y la visibilidad que tendrá en el contexto en que se utilice. La última versión de Spring define 6 tipos de scopes: singleton, prototype, request, session, application y websocket. Los últimos 4 sólo están disponibles para aplicaciones web. Scope Singleton: el contenedor crea una única instancia de ese bean y todos los request que se hagan a ese bean retornarán el mismo objeto que queda cacheado. Cualquier modificación que se realice sobre el objeto se reflejará en las referencias al bean. Este scope es el definido por defecto si no se especifica otra cosa. Scope Prototype: un bean con este scope retornará una instancia diferente cada vez que se le haga un request desde el contenedor. Se puede setear mediante la anotación Scope o utilizando mediante una constante. Scopes web: el scope Request crea una instancia de bean para un request HTTP, mientras que el Scope Session crea una instancia de bean para una sesión HTTP. El scope Application crea una instancia de bean para el ciclo de vida de un ServletContext y el Scope Websocket crea una instancia de bean para una sesión particular Websocket. 

* Anotación Bean Property: utilizado para caracterizar información relacionada  

* Diferencia entre RequestMapping y GetMapping: RequestMapping es utilizado a nivel de clases (y de métodos, indicando su RequestMethod) mientras que GetMapping es utilizado a nivel de métodos. GetMapping es una anotación combinada, la abreviatura de RequestMethod.GET

### Testing
* Librerías JUnit: JUnit es un framework open source para la automatización de pruebas unitarias y de integración en proyectos de software. Estas librerías que son parte del framework proveen herramientas, clases y métodos que facilitan la tarea y a la vez dan consistencia y funcionalidad.Se compone los métodos setUp, tearDown, métodos auxiliares y anotaciones como RunWith (se le asigna a una clase a la que JUnit invocará en lugar del ejecutor por defecto de la librería), Before (indica que el método anotado se debe ejecutar antes de cada test y precede al método setUp), After (indica que el método anotado se debe ejecutar después de cada test) y Test (indica al framework que este es un método de test)

* Mockito: Java Mockito es un framework de mock utilizado para crear objetos mock que permiten simular un objeto real y eliminar las dependencias permitiendo que los test se ejecuten de forma aislada. Los mock objects son objetos que simulan parte del comportamiento de una clase. Mockito es una api basada en EasyMock. El uso de mockito se basa en el concepto de stubbing que se refiere a ejecutar y verificar los comportamientos, se programa un comportamiento, se ejecutan las llamadas y se verifican.

* Argument matchers: permiten realizar llamadas a métodos mediante comodines de forma que los parámetros no se tengan que definir explícitamente. Permiten realizar stubbing o verificaciones muy flexibles.

* Diferencia entre assert y verify: con el comando assert, en cuanto la validación del elemento que se está evaluando falla, el test se detiene y se marca como fallido, en cambio con verify, aunque la evaluación falle, la ejecución continúa con el resto de evaluaciones que correspondan, aunque finalmente igual quede marcado como fallido.

* Forma de probar métodos privados: lo ideal es no probar métodos privados directamente, sino que probarlos con uno o más test que llamen a uno o más métodos públicos. Si un método privado devuelve un resultado, eventualmente ese resultado va a ser utilizado por un método público. Si el resultado es incorrecto el comportamiento del método público también será incorrecto, así que de esta forma el conjunto de test sobre el método público prueba el método privado. En el caso de los métodos con side effect, si el método privado genera un side effect y luego este mismo se utiliza luego en otro método público que modifique este valor dado por el side effect entonces se va a poder probar el método privado a través de los test que prueban el método público que utiliza el valor del side effect.

* ¿Se pueden hacer mocks de métodos static? En general los métodos static se utilizan para implementar funciones que pertenecen a la clase como un todo y no a un objeto particular de la clase. Este tipo de métodos pueden ser llamados sin necesidad de crear un objeto de la clase que lo contiene. La forma de mockear este tipo de métodos es mediante el uso de la librería Mockito, con JUnit 4 y PowerMock

* Test de integración: es un test más completo en que se levanta el servidor y se prueban una a una todas las capas de la arquitectura de la aplicación. Es posible en este test conectar con la base de datos o conectar con una bdd de prueba o incluso mockear la base de datos. Este tipo de test prueba todo y pasa por todas las capas.

### Bases de datos
* Qué es una base de datos: es una colección de información que se estructura en de manera que es de fácil manejo y actualización. Para lograr este objetivo se han creado varios DBMS (Database Management System)

* Qué es un index en bases de datos: es una estructura de datos que permite mejorar la rapidez de las búsquedas por medio de un índice único de cada fila de una tabla, lo que permite un acceso más rápido a los registros de la tabla.

* Diferencia entre truncate y drop: drop elimina un objeto con todo su contenido de la base de datos, es una eliminación física de la tabla, la vista, los índices o toda la base de datos, mientras que truncate elimina solamente los datos de la tabla, pero la tabla continúa existiendo.

* Qué es un pool de conexión: es el límite de conexiones que puede tener una base de datos.

* Qué es una vista en bases de datos: es una tabla virtual cuyo contenido está definido por una consulta. Es un elemento que no es realmente una tabla pero cuenta con elementos que son parte de otras tablas.

* JMS: es una API de mensajería estándar para JEE y con el objetivo de contar con un sistema de envío y recepción de mensajes asíncronos relacionados con eventos y data de negocio. 

* Fetch type: es una propiedad que habla de la forma en que se deben cargar los valores de una entidad cuyos datos se encuentran en una base de datos. Hay dos formas principales de fetch type, son Lazy e Eager. Esta propiedad se señala como anotación sobre un atributo de la entidad indicando a cuál tipo va a corresponder.
	* Eager loading: es la forma que trae de una vez todos los datos de una entidad, sea que los vayamos a ocupar o no. Esta forma “ansiosa” no es tan eficiente cuando tenemos una cantidad muy grande de datos, sobre todo porque existe la probabilidad de que no sea necesario usarlos todos.
	* Lazy loading: es la forma de traer o cargar datos bajo demanda, en la medida que se solicitan a través de un método get(). Esta forma es más eficiente en cuanto a consumo de recursos.

* SQL vs JPQL: sql trabaja con tablas de bases de datos relacionales mientras que jpql trabaja con clases de java y objetos.

* Anotación transactional: las transacciones en bases de datos corresponden a un proceso lógico que se efectúa sobre una o varias tablas y que permite realizar, según lo indique el proceso, actualizar, insertar o borrar registros pero entregando seguridad al ejecutar el procedimiento debido a que se deben cumplir una serie de parámetros para realizar estos cambios de manera exitosa. Para finalizar una transacción con seguridad se realiza un commit, pero no de no haber sido exitosa se procede a realizar un rollback, quedando sin efecto los cambios realizados. Commit es aplicar cambios y rollback es cancelar cambios. La anotación Transactional permitiendo que los métodos begin(), commit() o rollback() de manera automática en vez de manual, verificando una serie de pasos o requisitos y actuando en base a ellos: required, supports, mandatory, required_new, not_supported, never y nested.

* ACID: en bases de datos este es el nombre de las características que deben tener los parámetros que permiten clasificar transacciones en sistemas de gestión de bases de datos. Una acción ACID compliant significa que es una acción que permite realizar transacciones. Atomicidad: transacciones completas, si hay una serie de pasos se realizan todos o ninguno. Consistencia: o integridad de los datos para validar que la base de datos siempre tenga valores exactos y consistentes, se mantengan intactos y no cambien ni se deformen. Aislamiento: esta propiedad asegura que una operación no afecte a otras, para que si hago dos transacciones sobre la misma información, éstas sean independientes y no generen ningún tipo de error. Durabilidad: o persistencia, es la propiedad que asegura que los datos sobrevivan y luego de realizada cualquier operación, ésta persista y no se pueda deshacer.

* Qué son los inner y outer joins: todos los joins tienen que ver con teoría de conjuntos (aunque no tienen que ver sólo con esto). El inner join es la intersección de dos tablas. El outer join es lo que queda fuera de la intersección de dos tablas. El left join es la suma de la intersección de dos tablas sumado con la tabla completa de la izquierda, y el right join lo mismo pero con la tabla de la derecha.

* Diferencias entre MySQL y PostgreSQL: MySQL es el RDBMS (Relational Database Management System) más famoso. En este sistema los datos se almacenan en tablas que hacen sencillas las operaciones CRUD (Create, Read, Update y Delete). PostgreSQL es un sistema de tipo Objeto-relacional que provee un buen desempeño con bajos esfuerzos de mantención debido a su alta estabilidad. Este sistema de base de datos fue el primero que se implementó con la característica de multi-version concurrency control (o control de concurrencia mediante versiones múltiples MVCC). Así que Postgre es más avanzado que MySQL, MySQL es más simple y rápido que Postgre, Postgre se usa comúnmente para operaciones más grandes y complejas mientras que MySQL se usa principalmente para operaciones simples de escritura y lectura de datos. 
* MVCC control de concurrencia mediante versiones múltiples es un método para control de acceso usado en bases de datos para proporcionar acceso concurrente a los datos y así implementar concurrencia en el lenguaje de programación. Esto significa que en la base de datos se implementan actualizaciones de los datos sin borrar los datos antiguos sobre escribiéndolos, sino que marcándolos como obsoletos y añadiendo los nuevos.

### Maven
* Apache Maven es una herramienta de gestión de proyectos que se utiliza para gestión de dependencias, como herramienta de compilación y como herramienta de documentación. Maven es una herramienta declarativa, es decir que todo lo que se defina como dependencias y módulos se almacena en un archivo xml que Maven lee cuando funciona. Maven permite gestionar dependencias, compilar código fuente, empaquetar código, instalar paquetes, generar documentación y gestionar las distintas fases del ciclo de vida de las aplicaciones construidas.

* Función del repository de maven: Maven cuenta con una matriz de repositorios remotos donde se puede localizar y descargar todo lo necesario para generar un proyecto. Para la gestión de estos repositorios existen algunas herramientas como Nexus, Archiva y Artifactory. Se diferencian en el tamaño que ocupan y el porcentaje respecto del tamaño original del repositorio.

* Función del pom.xml: el pom o Project Object Model es la unidad básica de trabajo en Maven, se trata de un archivo de tipo xml que se encuentra por defecto en la raíz de todos los proyectos y que contiene toda la información del proyecto: configuración, dependencias, versiones, etc. 

### Cloud
* Servicios Cloud en GCP: Platform as a Service (App Engine) offers a flexible, scalable cloud platform to develop, deploy, run and manage apps. This includes infrastructure, development tools, operating systems and all the tech stack resources. Infrastructure as a Service (Compute Engine) provides access to compute, storage, networking and virtualization, and the customer manages everything else: virtual machines, operating systems, apps and data, but frees the customer from maintaining its own data center infrastructure. Software as a Service provides the entire application stack, from hardware infrastructure, updates, bugs fixes and all the general maintenance of the components. GCP has Compute products (Compute Engine for creating virtual machines, Google Kubernetes Engine for deploying, scale and managing containers, as well as Cloud Run), Storage (Cloud Storage, storage transfer service and persistence disk block storage), Databases (SQL databases fully managed, Cloud SQL and database migration systems), Data analytics (Big Query and Looker), Networking (Cloud CDN and Cloud Armor), Machine learning (Vertex AI) and developer tools (Cloud Build, Cloud Code).
* Serverless computing in GCP is Google Cloud Functions: is a service that allows to run the code on the cloud.
* API management in GCP is Cloud Endpoints.
* Servicios IAM: Identity Access Management se trata de la gestión y administración  de identidades y accesos a diferentes servicios y recursos en la nube tanto de GCP como de AWS. El servicio IAM permite configurar y administrar barreras de protección y controles específicos para los miembros de una empresa, administrar todas las identidades de una cuenta centralizada, conceder credenciales de seguridad temporales y una plataforma para analizar los accesos. Generalmente se trabaja desde la filosofía del privilegio mínimo, siendo necesario conceder en cada caso los permisos extra y no al revés. 
* Dockerfile: palabra clave “from” indica desde dónde se va a crear la imagen. Docker run cualquierNombre crea una imagen que no existe. Docker ps muestra la imagen que está corriendo actualmente. Docker run –name [nombre] crea un container. 
* Una imagen es una plantilla, una herramienta de construcción y distribución de software. Un container es la ejecución de una imagen, es la unidad de trabajo básica o elemental de Docker. El container es distinto a una máquina virtual, pero se parecen. La diferencia es que el container no tiene sistema operativo guest. Una máquina virtual es un software que emula una computadora, tiene sistema operativo, ram, cpu, etc. Docker file es una serie de instrucciones que sigue el motor de docker para construir una imagen.
* Kubernetes: Un Pod puede contener tan sólo un container, o más de un container y también un volumen. Un nodo está conformado por varios Pods. Un cluster de Kubernetes está compuesto por varios nodos, nodos de procesos y masters. 
* Componentes generales de AWS: Lambda is serverless computing and Amazon API gateway is API management. EC2 is Amazon elastic compute cloud, which is Infrastructure as a Service. Amazon S3 is the Simple storage service.

### Agile
* Agile es una mentalidad que permite responder al cambio y está definida por 4 valores (Respuesta al cambio, individuos e interacciones, colaboración con el cliente y software funcionando) y guiada por 12 principios (satisfacer al cliente, aceptar y aprovechar el cambio, trabajar y colaborar juntos, promover un ritmo sostenible, comunicar información cara a cara, medir el progreso mediante producto funcionando, mantener la simplicidad, promover equipos auto-organizados, entregar frecuentemente y en menor tiempo posible, atender continuamente la excelencia técnica, mejorar continuamente y motivar a la personas ofreciendo un entorno de confianza). 
* El agilismo se manifiesta a través de frameworks, prácticas y técnicas, y sirve para descubrir mejores formas de desarrollar software, promoviendo modelos de organización centrados en las personas y la colaboración. Los beneficios de aplicar Agile es que permite tomar decisiones rápidas que aporten valor al negocio de manera temprana.
* Agile es importante porque pone al cliente en el centro, busca la mejora continua y el aprendizaje, es una forma eficiente para trabajar y organizarse, permite la adaptación a un entorno cambiante, permite la obtención de feedback del cliente y permite gestionar la incertidumbre. El desarrollar una mentalidad agile nos permite la mejora continua del proceso y del producto.
* Lo que se espera en cuanto al producto es el MVP, minimum viable product. No se espera conseguir el 100% de la funcionalidad en un primer momento sino que priorizar funcionalidades que aporten valor y que permitan iterar sobre sí mismo.
* Scrum es un framework que permite ejecutar una serie de interacciones en equipo, definiendo el qué y el quién, identificando roles y responsabilidades de cada uno de los miembros del equipo. Define también el dónde y el cuándo que representan el Sprint y el por qué y el cómo que son las herramientas que utilizan. 
* Los eventos ágiles son aquellos en que el equipo se reúne a hablar sobre los próximos pasos a seguir: Sprint planning, Daily, Retrospectiva, Review, entre otras. 
* Los artefactos son los elementos que garantizan la transparencia y registro de la información fundamental del proceso: product backlog es un ejemplo de artefacto. Una historia de usuario es una explicación general e informal de una función de software escrita desde la perspectiva del usuario final o cliente. El propósito de una historia de usuario es articular cómo un elemento de trabajo entregará un valor particular al cliente. 
* Scrum es un framework que ayuda a las personas, equipos y organizaciones a generar valor a través de soluciones adaptativas a problemas complejos. Sus pilares son la transparencia, la inspección y la adaptación. Es clave conocer los roles y responsabilidades porque permite saber qué es lo que se espera del desarrollador y qué esperar del equipo: 
	* Sponsors corresponde casi siempre al gerente general del negocio o del área y tiene la última palabra en temas de priorización. 
	* Stakeholders son personas del negocio que interactúan con los gerentes de producto. 
	* Focal points son representantes de los stakeholders en el día a día y pueden asistir a los refinamientos, los reviews y las priorizaciones. 
	* El Product Owner es el responsable de maximizar el valor del producto resultante del trabajo del equipo. Sus objetivos son desarrollar y comunicar explícitamente el objetivo del producto, crear y comunicar los elementos del backlog, ordenar los elementos del backlog y asegurarse de que éste sea transparente, visible y entendible. 
	* El Scrum Master es responsable de lograr la efectividad del equipo, sirviendo como líderes que sirven al equipo y la organización. 
	* El equipo de desarrollo está compuesto por desarrolladores, líder técnico, user experience y quality assurance. Todo este equipo se compromete a crear cualquier aspecto de un incremento de producto. Un Sprint es un ciclo de determinada cantidad de tiempo, 2 semanas, por ejemplo, donde se toma una porción del backlog para entregar un incremento de producto. Durante el Sprint se busca alcanzar el objetivo y mantener el foco en lo más importante.

### Git
* Es una herramienta de colaboración y versionamiento de aplicaciones. Gitflow es lo más usado, se trabaja en diferentes ramas y luego se va revisando. Un aspecto importante aquí es que git flow permite separar en los distintos ambientes y el código debe ser revisado mediante merge request y no pasa automáticamente a las ramas principales.
	* Rama develop: es la que se utiliza para el ambiente de desarrollo, para desarrollar los elementos de la aplicación.
	* Rama feature: se crea a partir de la rama develop y se asigna para cada una de las funcionalidades en las que debe trabajar el equipo. Cada rama feature se asigna a un desarrollador, quien trabaja y hace sus commits hasta que finalizada su tarea se llevan los cambios a la rama develop. Las ramas feature nacen y mueren en la rama develop.
	* Rama bug fix (hotfix): estas ramas nacen en la rama master y se utilizan para trabajar en la corrección de algún bug. En esta rama se aplican los cambios, se valida su funcionamiento y se vuelve a master, momento en el que esta rama muere y su modificación se replica también en la rama develop.
	* Rama master (ahora main): es la rama destinada únicamente al ambiente de producción. En esta rama se generan los tag de versionamiento de las aplicaciones.
	* Rama release: esta rama es la intermediaria entre la rama develop y la rama master. Se utiliza para darle estabilidad a los elementos que pasan a la rama master, ya que la rama develop al recibir los elementos de las ramas feature que son de por sí inestables, vuelven también inestable a la rama develop. Esta rama nace en develop y muere en la rama master. 
	* Git push: comando utilizado para subir un repositorio local a un repositorio remoto. Es la forma en que se transfieren los commits desde el repositorio local al repositorio remoto. Git push es lo contrario a git fetch.
	* Git fetch: es la contraparte de git push. Es el comando que se utiliza para importar commits desde un repositorio remoto a las ramas locales.
	* Git pull: es el comando que se utiliza para traer y descargar contenido desde un repositorio remoto e inmediatamente actualizar el repositorio local para que ambos tengan el mismo contenido.  
	* Git merge: este comando permite tomar líneas de desarrollo independiente e integrarlas en una sola rama. 
Git rebase: es un comando utilizado para el proceso de mover o combinar una secuencia de commits en un nuevo commit de base. Esta estrategia es de mayor utilidad cuando se visualiza en el contexto de feature branching.
Git commit: un commit es como un snapshot de un repositorio. Los commits son como las unidades fundamentales de un proyecto que utiliza Git y son como hitos o instantáneas a lo largo de toda la línea de tiempo del proyecto.
